#!/usr/bin/env python
# encoding: utf-8
'''
create_abricate_file -- shortdesc

create_abricate_file is a description

It defines classes_and_methods

@author:	 user_name

@copyright:  2023 organization_name. All rights reserved.

@license:	license

@contact:	user_email
@deffield	updated: Updated
'''

import sys
import os

from Bio import SeqIO
from Bio.SeqRecord import SeqRecord

from optparse import OptionParser

__all__ = []
__version__ = 0.1
__date__ = '2023-04-04'
__updated__ = '2023-04-04'

### the description file must have this header
HEADER_FILE = ["sequence", "id", "accession"]

def get_seq_names(tsv_file):
	"""
	Read TSV file, "SeqName Name1 Name2"
	Header -> "sequence\tid\taccession"
	"""
	
	
	# First, we create a dictionary to store the mapping between SeqName and the corresponding Name1 and Name2
	seqname_to_names = {}
	b_header = False
	with open(tsv_file, 'r') as tsv:
		for line in tsv:
			try:
				seqname, name1, name2 = line.strip().split('\t')
				if not b_header:
					if seqname.lower() != HEADER_FILE[0] or name1.lower() != HEADER_FILE[1] or\
							name2.lower() != HEADER_FILE[2]:
						sys.exit("Error: file '{}' must have this header: '".format(tsv_file) + "\t".join(HEADER_FILE) + \
								"'.\nThe file must be tab separated value (tsv).")
					b_header = True
					continue
			except Exception as e:
				sys.exit("Error: this line '{}' does not have three fields. File '{}'.".format(
					line.strip(), tsv_file))
			if seqname in seqname_to_names:
				sys.exit("Error: Seq.Name '{}' is repeated in the file '{}'.".format(seqname, tsv_file))
			seqname_to_names[seqname] = (name1, name2)
	return seqname_to_names

def main(argv=None):
	'''Command line options.'''

	program_name = os.path.basename(sys.argv[0])
	program_version = "v0.1"
	program_build_date = "%s" % __updated__

	program_version_string = '%%prog %s (%s)' % (program_version, program_build_date)
	#program_usage = '''usage: spam two eggs''' # optional - will be autogenerated by optparse
	program_longdesc = '''Add id and accession values to a fasta file, to be compatible with abricate input.
	Header file: ''' + "\t".join(HEADER_FILE) + ''' ''' # optional - give further explanation about what the program does
	program_license = "Copyright 2023 user_name (iBiMED)											\
				Licensed under the Apache License 2.0\nhttp://www.apache.org/licenses/LICENSE-2.0"

	if argv is None:
		argv = sys.argv[1:]
	try:
		# setup option parser
		parser = OptionParser(version=program_version_string, epilog=program_longdesc, description=program_license)
		parser.add_option("-f", "--fasta", dest="fasta", help="set input fasta file.", metavar="FILE")
		parser.add_option("-s", "--samples", dest="samples", help="set input sample description table file. Must be tab separated value (tsv) and with this header: " +\
						"\t".join(HEADER_FILE), metavar="FILE")
		parser.add_option("-o", "--out", dest="outfile", help="set output fasta file.", metavar="FILE")


		# process options
		(opts, args) = parser.parse_args(argv)

		if opts.fasta: print("fasta = %s" % opts.fasta)
		if opts.samples: print("samples = %s" % opts.samples)
		if opts.outfile: print("outfile = %s" % opts.outfile)

		if (not os.path.exists(opts.samples)): sys.exit("Error: file '{}' does not exist...".format(opts.samples))
		if (not os.path.exists(opts.fasta)): sys.exit("Error: file '{}' does not exist...".format(opts.fasta))
			
	except Exception as e:
		sys.stderr.write(program_name + ": for help use --help\n")
		return 2

	### get the table
	dt_seq_names = get_seq_names(opts.samples)
	
	# Then, we read the fasta file and create a new fasta file with the modified sequence names
	records = []
	vect_id_not_found = []
	with open(opts.fasta, 'r') as handle_in:
		for record in SeqIO.parse(handle_in, "fasta"):
			if record.id in dt_seq_names:
				records.append(SeqRecord(record.seq,
					id = "{}~~~{}~~~{}".format(record.id, dt_seq_names[record.id][0],
					dt_seq_names[record.id][1]), description=""))
			else: vect_id_not_found.append(record.id)

	## write sequences
	if len(records) > 0:
		with open(opts.outfile, 'w') as handle_write:
			SeqIO.write(records, handle_write, "fasta")
			
			print("File saved: {}".format(opts.outfile))
	else:
		print("File NOT saved: {}".format(opts.outfile))
	print("Seqs. parsed: {}".format(len(records)))
	print("Seqs. not parsed: {}".format(len(vect_id_not_found)))
	if len(vect_id_not_found) > 0: print("\tIDs: {}".format(",".join(vect_id_not_found)))


if __name__ == "__main__":
	sys.exit(main())
	
